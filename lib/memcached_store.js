// Generated by CoffeeScript 1.6.2
(function() {
  var Async, Memcached, MemcachedStore, ObjectStore, microtime, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Memcached = require('memcached');

  microtime = require('microtime');

  ObjectStore = require('./object_store');

  Async = require('async');

  _ = require('lodash');

  MemcachedStore = (function(_super) {
    __extends(MemcachedStore, _super);

    function MemcachedStore(location) {
      if (location == null) {
        location = 'localhost:11211';
      }
      this.memcached = new Memcached(location);
      this.default_expire = 10000;
    }

    MemcachedStore.prototype.get = function(key, callback) {
      return this.memcached.get(key, function(err, data) {
        if (err) {
          throw err;
        }
        return callback(err, data);
      });
    };

    MemcachedStore.prototype.set = function(key, value, callback) {
      var expire;

      expire = this.default_expire;
      return this.memcached.set(key, value, expire, function(err, result) {
        if (err) {
          throw err;
        }
        return callback(err, result);
      });
    };

    MemcachedStore.prototype.del = function(key, callback) {
      return this.memcached.del(key, function(err, result) {
        if (err) {
          throw err;
        }
        return callback(err, result);
      });
    };

    MemcachedStore.prototype.has = function(key, callback) {
      return this.memcached.get(key, function(err, data) {
        var res;

        if (err) {
          throw err;
        }
        res = data === false ? false : true;
        return callback(err, res);
      });
    };

    MemcachedStore.prototype.keys = function(pattern, callback) {
      var _this = this;

      if (pattern == null) {
        pattern = "*";
      }
      return this.items(function(err, items) {
        var my_item, server, slab_ids;

        if (err) {
          throw err;
        }
        my_item = items[0];
        server = my_item.server;
        slab_ids = Object.keys(my_item);
        slab_ids.pop();
        return _this.getSlabKeys(server, slab_ids, callback);
      });
    };

    MemcachedStore.prototype.getSlabKeys = function(server, slab_ids, callback) {
      var all_keys, id, self, tasks;

      self = this;
      all_keys = [];
      tasks = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = slab_ids.length; _i < _len; _i++) {
          id = slab_ids[_i];
          _results.push((function(id, server) {
            return function(async_callback) {
              return self.cachedump(server, id, function(err, result) {
                all_keys = all_keys.concat(result);
                return async_callback(err, result);
              });
            };
          })(id, server));
        }
        return _results;
      })();
      return Async.series(tasks, function(err) {
        var _keys;

        _keys = _.map(all_keys, function(item) {
          return item.key;
        });
        return callback(err, _keys);
      });
    };

    MemcachedStore.prototype.cachedump = function(server, slab_id, callback) {
      return this.memcached.cachedump(server, +slab_id, 0, function(err, res) {
        var ret;

        ret = res instanceof Array ? res : [res];
        return callback(err, ret);
      });
    };

    MemcachedStore.prototype.flush = function(callback) {
      return this.memcached.flush(callback);
    };

    MemcachedStore.prototype.flushAll = function(callback) {
      var fnDelAll, fnFlush, fnKeys, self;

      self = this;
      fnFlush = function(cb) {
        return self.memcached.flushAll(cb);
      };
      fnKeys = function(res, cb) {
        return self.keys("", cb);
      };
      fnDelAll = function(keys, cb) {
        var k, tasks;

        tasks = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = keys.length; _i < _len; _i++) {
            k = keys[_i];
            _results.push((function(k) {
              return function(cb) {
                return self.memcached.del(k, cb);
              };
            })(k));
          }
          return _results;
        })();
        return Async.parallel(tasks, cb);
      };
      return Async.waterfall([fnFlush, fnKeys, fnDelAll], callback);
    };

    MemcachedStore.prototype.items = function(callback) {
      return this.memcached.items(function(err, result) {
        if (err) {
          throw err;
        }
        return callback(err, result);
      });
    };

    MemcachedStore.prototype.quit = function() {
      return this.memcached.end();
    };

    return MemcachedStore;

  })(ObjectStore);

  module.exports = MemcachedStore;

}).call(this);
